# Corning AI challenge _ ITEM 2 

### ğŸ´â€â˜ ï¸ ìƒì„±í˜• AIë¥¼ ì´ìš©í•œ inverse problem í•´ê²° ë°©ì•ˆ ì œì•ˆ


<br/>

ğŸ’¡ Purpose of project:

Inverse problems are mathematical problems where the goal is to find the underlying cause or source of a given effect. Inverse problems are commonly encountered in various fields such as physics, engineering, and image processing. In the field of design, inverse problems arise when the goal is to generate a design based on a given set of specifications or requirements. Traditional methods for solving inverse problems in design often require extensive computations and are prone to errors. To address this issue, weâ€™d like to solve inverse problems for optimized design pattern recommendation using generative AI methods.


<br/>

ğŸ”‘ Objectives:

The primary objective of this project is to investigate the use of generative AI methods for solving inverse problems for finding optimized design pattern. The following are the specific objectives of the project.


  * Be able to recommend 2-dimensional (or 3-dimensional) pattern satisfying a given target. (It can be anything related to pattern optimization. For example, find 2-dimensional electrode pattern satisfying a given electric field)


  * Recommended patterns should be listed in order of performance/process convenience (For example, feasibility of process can be judged by the continuity of the patterns or the large spacing between patterns.)


  * Final output should include the explanation of how the generative models work and why they make certain decisions.


<br/>

ğŸ“– ì°¸ê³  ë‚´ìš© (ì•„ë˜ëŠ” ë‹¨ì§€ ì˜ˆì‹œì´ë©°, ë‹¤ë¥¸ ì£¼ì œë¥¼ ì„ ì •í•˜ì—¬ë„ ìƒê´€ ì—†ìŠµë‹ˆë‹¤) 

âœ”ï¸ Electric field generated by 2-d electrode pattern

![image](https://github.com/CORNING-AI-CHALLENGE/item2/assets/146830948/196055c2-f172-436c-a766-71fb4bdf20ca)


(ìœ„ì˜ ì‹ì—ì„œ ê³„ì‚° í¸ì˜ìƒ A=1ì´ë¼ ê°€ì •)
```python
import numpy as np
import numba as nb

@nb.jit(nopython=True, parallel=True)
def cal_field(input_pattern):
    dimx, dimy = input_pattern.shape 
    field_x = np.zeros((dimx,dimy))
    field_y = np.zeros((dimx,dimy))
    field_z = np.zeros((dimx,dimy))
    for i in range(dimx):
        for j in range(dimy):
            tmp_x = 0.
            tmp_y = 0.
            tmp_z = 0.
            for ii in range(dimx):
                for jj in range(dimy):
                    tmp_x += input_pattern[ii,jj]*(i-ii)/(((i-ii)**2+(j-jj)**2+1**2)**(3/2))
                    tmp_y += input_pattern[ii,jj]*(j-jj)/(((i-ii)**2+(j-jj)**2+1**2)**(3/2))
                    tmp_z += input_pattern[ii,jj]*(1.)/(((i-ii)**2+(j-jj)**2+1**2)**(3/2))
            field_x[i,j] = tmp_x
            field_y[i,j] = tmp_y
            field_z[i,j] = tmp_z
    return field_x,field_y,field_z
```


âœ”ï¸ Convolutional autoencoderë¥¼ ì´ìš©í•œ electrode pattern ì˜ˆì¸¡ base code (input=41x41x3, output=41x41x3, í•´ë‹¹ dimensionì€ ì˜ˆì‹œ)

Model
```python
input = layers.Input(shape=(41, 41, 3))

# Encoder
x = layers.Conv2D(512, (3, 3), activation="relu", padding="same")(input)
x = layers.MaxPooling2D((2, 2), padding="same")(x)
x = layers.Conv2D(128, (3, 3), activation="relu", padding="same")(x)
x = layers.MaxPooling2D((2, 2), padding="same")(x)

# Decoder
x = layers.Conv2DTranspose(128, (3, 3), activation="relu", padding="same")(x)
x = layers.UpSampling2D((2, 2))(x)
x = layers.Conv2DTranspose(512, (3, 3), activation="relu", padding="same")(x)
x = layers.UpSampling2D((2, 2))(x)
x = layers.Conv2D(3, (3, 3), activation="sigmoid", padding="same")(x)
x = layers.Cropping2D(cropping=((3, 0), (3, 0)), data_format=None)(x)

# Autoencoder
autoencoder = Model(input, x)
autoencoder.compile(optimizer="adam", loss="binary_crossentropy")
autoencoder.summary()
```

Train
```python
autoencoder.fit(x=[array],y=[array],epochs=[number])
```

Prediction
```python
predictions = autoencoder.predict([array])
```

âœ”ï¸ ì˜ˆì¸¡ ê²°ê³¼ ì˜ˆì‹œ 

![image](https://github.com/CORNING-AI-CHALLENGE/item2/assets/146830948/3c069f00-74e4-492e-a99d-6adb782b49cd)





